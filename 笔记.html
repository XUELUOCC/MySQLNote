<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            padding:0;
            margin:0;
        }
        .container{
            width:300px;
            margin:100px auto;
            border:1px solid #ddd;
            padding:10px;
        }
        p{
            width:100%;
            /* padding:10px 0 0px; */
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            text-align: justify;
            overflow: hidden;
            word-wrap:break-word;  /*如果文本是英文的话，英文是不会自动换行的，需要设置word-wrap  word-break*/
            word-break:break-all;  /*如果文本是英文的话，英文是不会自动换行的，需要设置word-wrap  word-break*/
        }
    </style>
</head>
<body>
    <div class="container">
        <p>
            bdfdfbhvgjhhbfvjsdfklbvhjsdfklbvsdffvbjsdflbvjsdfbvjdsflvbjsdfbvgbugdjfvbhjfd
            不瞌睡放不进代付款时间了白
            bdfdfbhvgjhhbfvjsdfklbvhjsdfklbvsdffvbjsdflbvjsdfbvjdsflvbjsdfbvgbugdjfvbhjfd
        </p>
    </div>
    
    
    <script>
        /*
        注意：
        1.MySQL是不见;分号，不执行SQL语句，分号;才是结束
        2.数据库中的字符串都是单引号，双引号不能用，不过MySQL中可使用双引号
        3.数据库中只要有null参与的运算结果一定是null（但分组函数自动忽略null，不影响），可通过ifnull处理null的数据
        4.null不是一个值，null是什么也没有
        5.SQL的一些语句的执行顺序：
            select
                ...
            from
                ...
            where
                ...
            group by
                ...
            having
                ...
            order by
                ...
            limit
                0,5
            执行顺序：
            --1.from  查找表
            --2.where 筛选条件
            --3.group by 对数据进行分组
            --4.having 对分组的数据进行过滤
            --5.select  查找整体数据中的一部分字段数据
            --6.order by 对数据进行排序并输出
            --7.limit 取出下标从0开始，长度为5的数据
        6.数据库中的命名规范：所有的标识符都是小写，单词与单词之间使用下划线_进行衔接

            1.数据库概括
                --简称：DB
                --按照一定格式存储数据的一些文件的组合

            2.数据库管理系统
                --简称DBMS
                --数据库管理系统是专门用来管理数据库中的数据，数据库管理系统可以对数据库中的数据进行增删改查
                --常见的数据库管理系统：MySQL,Oracle,MS SqlServer,DB2,sybase等

            3.SQL语句
                --程序化查询语句
                --可通过编写SQL语句，然后DBMS执行SQL语句，实现增删改查

            4.windows下的以命令行执行MySQL的启动和停止
                --通过管理员身份启动cmd
                    --启动：net start 服务器名称（MySQL）
                    --停止：net stop 服务器名称（MySQL）
                --查看服务：  此电脑>管理（属性）>管理和应用程序（服务）

            5.本地登录MySQL
                --以管理员身份运行cmd （前提是MySQL服务已启动）
                    --执行 $mysql -uroot -p123456    (输入数据库的用户名和密码)
                    --登录进入后界面：
                        mysql>...
                    --退出：
                        mysql>exit
                --隐藏密码格式：
                    --$mysql -uroot -p

            6.MySQL的常用命令：
                命令不区分大小写
                --退出：exit
                --查看MySQL有哪些数据库：show databases;(以分号结尾)
                --选择使用某个数据库：use test;(选择使用test的数据库，以分号结尾)
                --创建数据库：create database test1;(数据库名称，以分号结尾)
                --删除数据库：drop database test;(数据库名称)
                --查看数据库中存在的表：show tables; (前提是已经使用了某个数据库，即执行use test类似的命令)
                --查看mysql数据库的版本号：select version();
                --查看当前使用的数据库：select database();
                --查看数据库中的表结构： desc user_table;(表名)

            7.数据库中的表：
                --定义：数据库中的最基本的单元
                --数据库中是以表格的形式表示数据库，因为表比较直观
                --组成：
                    行（row）:称为数据/记录
                    列（column）:称为字段
                        --字段属性：字段名，数据类型，约束等属性
                            --约束：约束有很多，其中一个叫做唯一性约束，这种约束添加之后，该字段的数据不能重复

            8.SQL语句的分类：
                --DQL:
                    数据库查询语言（带有select的查询语句）
                --DML：
                    数据库操作语言（操作数据库中的表中的数据）
                    --insert 增
                    --delete 删
                    --update 改
                --DDL：
                    数据定义语言
                    凡是带有create ,drop,alert的都是DDL
                    DDL主要是操作表的结构，不是表中的数据
                    create:新建，类似于增
                    drop:删除
                    alert:修改
                --TCL:
                    事务控制语言
                    包括：
                        事务提交：commit;
                        事务回滚：rollback;
                --DCL:
                    数据控制语言
                    例如：授权grant,撤销权限revoke

            9.导入sql文件到数据库中
                命令：$source D://...(导入文件的路径，路径中不能存在中文);

            10.查看表中的数据
                执行SQL中的DQL,查询语句
                命令：$select * from test(表名);----查询某表的所有数据
                命令：$select 
            
            11.只查看表的结构，不查看表的数据
                命令：$desc test(表名);

            12.DQL查询语句
                --查询一个字段
                    select 字段名 from 表名
                    select name from user_table
                --查询多个字段
                    select 字段名,字段名 from 表名
                    select name,gender from user_table
                --查询所有字段
                    select * from 表名  
                        缺点：效率低，可读性低，不建议实际开发中使用
                    select 字段名,字段名... from 表名
                --使用as对查询的语句起别名（给查询的列起另一个名称，对原表不影响）
                    select 查询字段 as 别名 from 表名;
                    select 查询字段 别名 from 表名  （可省略as）
                    select name as newName,chinese as newChinese from user-table;  (对多个字段起别名)
                    别名出现空格的情况：
                    select name as 'queryName' from user_table; (加单引号''可解决别名中间出现空格的情况)
                    select name as 'query Name' from user_table;
                --字段可以使用数学表达式(加减乘除)
                    select math*2 from user_table;  (查询的是math字段乘以12的显示数据，查询出来的数据名称可通过别名修改)

                    select math*2 mathName from user_table; (将查询到的数据流通过别名进行重新定义，否则查询出来的名称就是math*2)
                    +-------------+
                    | mathName |
                    +-------------+
                    |         210 |
                    |         200 |
                    |          60 |
                    |          60 |
                    +-------------+
            13.DQL条件查询（使用where语句，当...）
                --条件：
                    () 括号——支持
                        --不确定优先级，就添加()
                    大于>
                    小于<
                    不等于 !=或者<>
                    等于 =
                    =null 不支持，只能使用is null
                        --因为数据库中的null代表什么都没有，所以不能使用等号=来衡量
                    两值之间的范围 —— 条件 between ... and ... (等同于——条件 >= and <= )
                        --必须是左小右大，否则就会出错
                        --select chinese from user_table where chinese between 30 and 100;
                    或者 or
                        --优先级比and低
                    并且 and 
                        --优先级比or高
                    is null 是空 ， is not null 不为空
                        --不能使用 !=null
                    包含 in (相当于多个or )
                        --并不是一个区间
                        --select * from user_table where chinese in (90,100,...) ————查找chinese=90或者是chinese=100的数据
                        --select * from user_table where chinese =90 or chinese chinese=100 ————查找chinese=90或者是chinese=100的数据
                    not 可以取非得意思，多用于 in或者is中
                        --not in （90,100） ————除了90或者是100之外的数据
                        --is not null  ————不是为null的数据
                    like 称之为模糊查询，支持%或是下划线匹配
                        --select name from user_table where name like '%o%'; ————查找表中的name字段中含有‘o’的数据
                        --select name from user_table where name like '%T'; ————查找表中的name字段以‘T’结尾的数据
                        --select name from user_table where name like 'T%'; ————查找表中的name字段以‘T’开头的数据
                        --select name from user_table where name like '_T%'; ————查找表中的name字段第二个字符是‘T’的数据
                        --select name from user_table where name like '__T%'; ————查找表中的name字段第三个字符是‘T’的数据

                    \ 转义字符
                        --可用于%和_，转义成普通字符
                        --%\_%   匹配到字段中含有‘_’的数据
                    % 匹配任意字符
                        --%o%  匹配字符中含有o的数据
                        --%T   匹配字符中以T结尾的数据
                        --T%   匹配字符中以T开头的数据
                    _ 下划线 一个下划线只匹配一个字符
                        --_   匹配到任意一个字符
                        --_T  匹配到第二个字符是‘T’的数据
                        --__T 匹配到第三个字符是‘T’的数据
                --查询符合条件的数据
                    select name,gender from user_table where englist=120; (查询表中englist=120时的name和gender字段)
            
            14.DQL设置查询排序
                --对查询的数据的单个字段进行排序
                    --默认是升序
                    --order by 
                        --升序 
                        --select name,gender,chinese,math from user_table order by chinese 
                            --对查询出来的数据通过chinese的数值进行升序（从小到大排序）
                    --order by 字段名 desc  
                        --降序
                        --select name,gender,chinese,math from user_table order by chinese desc
                    --order by 字段名 asc 
                        --指定升序
                        --select name,gender,chinese,math from user_table order by chinese asc;
                --对查询的数据多个字段进行排序
                    --现指定一个排序，如果前面的排序不能排序出来（例如第一个字段相等）,此时需要第二个字段指定排序规则，进行排序
                    --select 
                        name,gender,chinese,math 
                    from 
                        user_table 
                    order by 
                        chinese asc,math desc;
                        --查找的数据按照chinese的升序排列，如果查找的数据chinese一样，就按照math的降序排列 (相当于对相等的数据做了一个排序判断)
                --根据字段的位置进行排序
                    --不建议开发中这样写，因为不健壮，因为列的顺序很容易发生改变
                    --select name,chinese from order by 2;  ————按照查询结果的第二列进行排序（即对第二列的数据指定排序规则）
            15.DQL单行数据处理函数
                --被称为，单行处理函数
                --特点：一个输入一个输出 （一次只对某一条数据进行处理，此次数据处理后才会处理下一条）
                --自动忽略null
                --与单行处理函数对应的是多行处理函数，多个输入对应一个输出（例如，得到多条数据的和，平均值等）
                --单行处理函数：
                    --字符串的起始下标是从1开始
                    --concat
                        --字符串拼接
                        --select concat(substr(name,1,1),'a') from user_table (查询到user_table中的name，截取字符串并拼接,最后输出)
                    --lower 
                        --转小写
                        select lower(name) from user_table;
                    --upper
                        --转大写
                            select upper(name) from user_table;
                    --substr
                        --取子串，类似于截取字符串
                        --substr(被截取的字符串，起始下标，截取长度)
                    --length
                        --长度
                    --trim
                        --去空格
                    --str_to_date
                        --将字符串转化成日期，通常使用在insert插入操作中，插入日期格式的数据
                    --date_format
                        --格式化日期，将日期转化成字符串
                    --format
                        --设置千分位
                    --round
                        --round(字段名变量，保留的位数)
                        --四舍五入
                        select round(123.45,1) from user_table  (123.45保留一位小数)
                        select round(123.45,-1) from user_table  (123.45保留十位)
                        select round(123.45,-2) from user_table  (123.45保留百位)
                    --rand()
                        --生成随机数
                    --ifnull
                        --可以降null转化成一个具体值
                        --ifnull(数据，为空时当成的具体值)
                        --处理为null的数据
                        --select name,ifnull(chinese,0)*12 from user_table （输出chinese*12的数据，当chinese=null时，其值等同于0）
                    --case...when..then..when..then..else..end
                        --不改变表格数据
                        --当..此时..当..此时..否则..结束
                        select 
                            name,
                            chinese,
                            math as oldMath,
                            (case math when 90 then chinese*1.5 when 100 then chinese*2 else chinese end)
                        as
                            result
                        from
                            user_table
                        (查找name,chinese,math,并且当math=90时输出chinese*1.5 当math=100时，输出chinese*2)
            
            16.DQL多行处理函数（分组函数）
                注意：
                    分组函数使用的时候必须进行分组，才能使用。如果没有对数据进行分组，则整张表默认为一组
                    分组函数不能使用在where语句中，因为在执行顺序上，执行到where时，并没有进行分组
                --多个输入对应一个输出（例如，得到多条数据的和，平均值等）
                --自动忽略null，处理的都是不为null的数据
                --多行处理函数：
                    --count
                        计数（计算有多少个数据）
                        count(字段名)---统计该字段下不为null的元素的总数
                        count(*)--统计的是该表的总行数，因为每一行数据不可能全部都为null
                    --sum
                        求和
                    --avg
                        平均值
                    --max
                        最大值
                    --min
                        最小值
            17.DQL的分组函数的分组查询
                --先进行分组，然后对每一组的数据进行操作
                --分组查询：
                    select 进行分组的字段，分组函数 from 表名 group by 进行分组的字段
                        --只能这样写，如果再添加一个另一个字段，在MySQL中可以执行，但毫无意义，但在Oracal中将会报错
                            --例如：select name,job,sum(sal)...  通过job职位进行分组，一个职位对应的是多个name，所以name和分组的数据并不对应
                    select job,sum(sal) from user_table group by job; (根据job进行分组，对每个job相同的数据进行工资sal求和)
                --多字段分组：
                    --例如：查找每个部门dept，不同的工作职位job的最高薪资sal的
                        select 
                            dept,job,max(sal) 
                        from 
                            user_table 
                        group by 
                            dept,job
                --对分组之后的数据进行过滤
                    --例如：查找每个部门dept的最高薪资sal，要求显示大于3000的最高薪资
                        方法一：先分组再过滤出大于3000
                            --使用having
                            --having必须和group by 联合使用，不能单独使用
                            缺点：效率低，having的效率低
                            select 
                                dept,max(sal) 
                            from 
                                user_table 
                            group by 
                                dept 
                            having 
                                max(sal)>3000
                        方法二：先找出大于3000的数据，然后再分组
                            select 
                                dept,max(sal) 
                            from 
                                user_table 
                            where 
                                sal>3000 
                            group by 
                                dept
                    --优化策略：
                        having和where,优先选择where，如果where处理不了的再选择having
            18.去除查询结果的重复记录
                --使用distinct,只能出现所有查询字段的最前方
                    select distinct name from user_table;
            19.连接查询（多表查询）
                --多张表联合起来查询数据，例如从表1中查询某字段，再从表2中查询某字段，这种跨表查询，被称之为连接查询
                --分类：
                    可根据语法年代分类：
                        --SQL92:1992年出现的语法
                        --SQL99:1999年出现的语法（一般使用SQL99的语法）
                    可根据表的连接方式分类 ：
                        --内连接：
                            --将两表中完全能匹配的数据全部显示查询出来
                            --内连接中不存在主次关系
                            等值连接
                                --条件是一个等值关系，相等关系
                                查询每个员工所在的部门名，user_table中存在员工名和部门编号，dept中存在部门编号和部门名称
                               --select 
                                    u.name,d.deptName 
                                from 
                                    user_table u
                                inner join（内连接吗，inner代表内连接）
                                    dept d 
                                on （筛选条件）
                                    u.deptno=d.deptno;
                            非等值连接
                                --条件是一个非等值关系，不是一个相等的关系
                                查询每个员工的薪资等级，emp表中存在具体薪资sal和员工名称name，gradeSal表中存在薪资的最高薪资hisal，最低薪资losal和薪资等级grade
                                --select 
                                    e.name,s.grade
                                from 
                                    emp e
                                join
                                    gradeSal s
                                on
                                    e.sal between s.losal and s.hisal;

                            自连接
                                --条件是在同一张表中的数据
                                --技巧：一张表需要看成两张表
                                查询员工的上级领导，显示上级领导名。user_table表中存在员工名，员工编号，员工对应的领导编号，其中领导也是员工，此时领导编号=员工编号
                                nameNo(员工编号) name(员工名) mgr(领导编号)
                                    7902            员工1         7930
                                    7930            员工2         7940
                                --select 
                                    a.name as '员工名',b.name as '领导名',
                                from 
                                    user_table as a
                                join
                                    user_table as b
                                on
                                    a.mgr=b.nameNo

                        --外连接
                            --除了两表匹配的数据显示出来，同时需要将第二张表的数据也显示出来，此时就需要使用外连接
                            --外连接中两张表中存在主次关系
                                --即，主表全部显示，次表只显示匹配的部分数据
                            --外连接的查询结果条数一定是>=内连接的查询结果条数
                            左外连接（左连接）
                            --将left join左边的表当作主表，右边的表是次表
                                查询每个员工所在的部门名，user_table中存在员工名和部门编号，dept中存在部门编号和部门名称
                                    --select 
                                        u.name,d.deptName 
                                    from 
                                        user_table u left outer(可省略) join dept d （left代表左外连接，左边的表是主表）
                                    on （连接查询的筛选条件）
                                        u.deptno=d.deptno;
                            右外连接（右连接）
                            --将right join右边的表当作主表，全部显示，左边的表是次表，只是捎带查询
                                查询每个员工所在的部门名，user_table中存在员工名和部门编号，dept中存在部门编号和部门名称
                               --select 
                                    u.name,d.deptName 
                                from 
                                    user_table u right outer(可省略) join dept d （right代表右外连接，右边的表是主表）
                                on （连接查询的筛选条件）
                                    u.deptno=d.deptno;
                        --全连接
                --笛卡尔积现象：
                    当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，会是两张表的乘积，这种现象被称为：笛卡尔积现象
                    select name,job from user_table,dept; (user_table中存在m条数据，dept表中存在n条数据，最终结果条数为m*n)
                --避免笛卡尔积现象：
                    --连接时添加条件（匹配的次数并没有减少，仍然是m*n,只不过是添加了筛选）
                        --select name,deptName from user_table,dept where user_table.deptno=dept.deptno;
                            (查询每个员工所在的部门名，user_table中存在员工名和部门编号，dept中存在部门编号和部门名称)
                --优化效率：
                    --表的连接次数过多，效率越低
                    --1.给表起别名，以此说明在哪个表中查询
                        SQL92语法：
                        SQL92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件都会放在where后面，使用and连接
                            --select 
                                u.name,d.deptName 
                            from 
                                user_table u,dept d 
                            where 
                                u.deptno=d.deptno;
                        SQL99语法：
                        SQL99的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后添加where
                            --select 
                                u.name,d.deptName 
                            from 
                                user_table u
                            join（连接）
                                dept d 
                            on （筛选条件）
                                u.deptno=d.deptno;
                    --2.减少表的连接次数

            20.两张以上表的连接查询（三张，四张表）
                ---内连接和外连接都可混合使用
                --select
                    ...
                from
                    a
                join 
                    b
                on
                    a和b的连接条件
                join 
                    c
                on
                    a和c的连接条件
                （a和b连接完成后，再连接c表。或者是a和b连接完成，a再和c连接）

            21.子查询
                --select语句中嵌套select语句，被嵌套的select语句被称为子查询
                --select
                    ..(select语句可出现)
                from
                    ..(select语句可出现)
                where
                    ..(select语句可出现)
                --where语句后的子查询
                    案例：
                        查询每个员工的最低工资
                        select 
                            name,sal 
                        from 
                            user_table 
                        where 
                            sal>(select min(sal) from user_table)
                --from语句后的子查询
                    --from后的子查询，可将子查询的查询结果当成一张临时表
                    案例：
                        查询每个岗位的平均工资的工资等级
                        --1.将查询出平均工资的查询结果当成一张临时表t
                        --2.再在salgrade表s 中查找工资等级，并和临时表连接查询
                        select 
                            t.*,s.grade
                        from
                            t
                        join
                            salgrade s
                        on
                            t.avg(sal) between losal and hisal;
                        ==>
                        select 
                            t.*,s.grade
                        from
                            (select job,avg(sal) avgsal(别名) from emp group by job) t
                        join
                            salgrade s
                        on
                            t.avgsal between losal and hisal;

            22.union合并查询结果集
                --将两个查询结果进行合并
                --优点：union的效率高一些，特别对于表的连接查询来说，因为表的连接次数满足笛卡尔积，次数会相乘成倍，
                        但union可以有效的降低连接的匹配次数，同时可以在减少连接的次数的情况下，完成两个结果集的拼接
                --注意：
                    在使用union的同时，要求查询的表的列数（字段数）需要相同
                --案例：查询工作岗位是‘manager’,‘salesman’的员工
                    select name from emp where job='manager'
                    union
                    select name from emp where job='salesman'
                    ===等同于
                    select name from emp where job in('manager','salesman')
                --案例：
                    a连接b,连接c 
                    a 10条记录
                    b 10条记录
                    c 10条记录
                    连接次数：10*10*10=1000次

                    使用union
                    a连接b  连接次数10*10=100
                    a连接c  连接次数10*10=100
                    使用union后，连接次数=100+100=200次

            23.limit
                --limit是将查询结果集的一部分取出来，通常使用在分页查询中
                --分页的作用：提交用户的体验
                --用法：
                    limit startIndex,length
                    默认下标为0
                    例如： limit 0,5  取出下标从0开始，长度为5的数据
                    例如：limit 5  同样是取出长度为5的数据，从下标为0开始
                --注意：
                    limit在order by之后执行
                --案例：按照薪资降序，取出前5名的员工
                    select
                        name,sal
                    from
                        emp
                    order by
                        sal desc
                    limit
                        5;  取出前五
            
            24.通用分页查询
                --案例：
                    每页显示pageSize条记录
                    第pageNo页：limit (pageNo-1)*pageSize,pageSize
                    第1页：limit 0,pageSize
                    第2页：limit (2-1)*pageSize,pageSize

            25.DQL语句总结
                select
                    ...
                from
                    ...
                where
                    ...
                group by
                    ...
                having
                    ...(分组之后的过滤操作)
                order by
                    ...(desc,asc)
                limit
                    0,3 (查找出下标为0，长度为3的数据)
                排序顺序：
                    1.from
                    2.where
                    3.group by
                    4.having
                    5.select
                    6.order by
                    7.limit 
            
            
            1.DDL语句———表的创建create
                --create table 表名(字段1 数据类型，字段2 数据类型，字段3 数据类型)
                --mysql的数据类型：
                    括号后面的是字符长度，不是字节
                    varchar(最长255) ：可变长度字符串，会根据实际的数据长度动态分配空间
                                        --使用： varchar(10)分配10个空间
                                        --优点：动态分配空间
                                        --缺点：需要动态分配空间，速度慢
                    char(最长255)    ：定长度字符串，分配的空间固定，并不会根据实际数据长度分配
                                        --使用：char(1)分配1个空间
                                        --不需要动态分配空间，速度快
                                        --缺点：使用不当可能会导致空间的浪费
                    int(最长11)      ：整数
                    bigint          ：长整数
                    float           ：单精度
                    double          ：双精度
                    date            ：短日期类型,只包括年.月.日
                    datetime        ：长日期类型，包括年.月.日.时.分.秒 日期信息
                    clob            ：字符大对象，最多可存储4G的字符串，比如：存储一篇文章，存储简介
                                        --超过255个字符的都需要采用CLOB字符大对象来存储
                    blob            :二进制大对象，专门用来存储图片、视频，声音等流媒体数据
                                        --往BLOB类型的字段上插入数据的时候，例如，插入一张图片，视频等，需要使用I/O流才行
                --案例：创建学生表
                    学号，姓名，年龄，邮箱
                    --create table t_student(
                        no int,
                        name varchar(32),
                        age int(3)  default 11,  //可通过default指定默认值
                        email varchar(255)
                    );

            2.DDL语句———删除表drop
                --drop table 表名;   //当这张表不存在时会报错
                --drop table if exits 表名; //如果这张表存在，就删除

            3.DML语句———向表中插入数据insert
                --注意：
                    --只要insert成功，一定会多一条数据，其中的数据的值是null，且这条记录不能修改
                    --字段名和values中的值需要一一对应
                    --表名后面的括号中的字段名顺序可以打乱，但必须和后面的values中的值对应
                    --如果表名后面的括号的字段省略，不写的话，等同于是将所有的字段全部写上
                --insert into 表名(字段1,字段2，字段3...) values(值1,值2,值3)
                    insert into t_student(no,name,age,email) values(11,'学生1',21,'123456@qq.com')
                --案例：
                    insert插入日期和查询日期:
                    1.先创建表
                    create table t_student1(
                        id int(11),
                        name carchar(32),
                        birth:date
                    )
                    2.再插入数据
                        --1.可直接插入，不做处理
                            原因：如果提供的日期格式是 %Y-%m-%d  ,即是1990-10-01这种格式，此时的str_to_date函数可省略,
                                因为此时mysql会自动进行类型转换
                                --values(1,'zhangsan','1990-10-01');
                        --2.如果想插入的date数据格式不是"1990-10-01"的格式
                            此时需要通过单行处理函数str_to_date,将字符串转化成date日期类型
                            --mysql中的日期格式： %Y 年 ， %m 月 ，%d 日 ， %h 时 ， %i 分 ， %s 秒
                            insert into t_student1(id,name,birth) values(1,'zhangsan',str_to_date('01/10/1990','%d/%m/%Y'));
                    3.查询日期数据
                        --1.可直接查询，不过显示的数据是"1990-10-01"的格式
                            原因： 如果需要将数据显示在窗口上，那么显示的数据必须是字符串类型，
                                其中mysql中将自动将数据中的date类型转化成date日期格式，
                                但其转化成的默认格式是 %Y-%m-%d 即1990-10-01格式
                        --2.如果需要显示的格式不是"1990-10-01"的格式，那么就需要使用date_format单行处理函数，将date类型数据转化成字符串
                            --select name,age,date_format(birth,'%m/%d/%Y') from t_student1;  //显示的是 月/日/年
                    4.插入长日期格式数据（datatime）
                        mysql中长日期默认格式：%Y-%m-%d %h:%i:%s
                        mysql中短日期默认格式：%Y-%m-%d
                            --长日期，短日期，mysql都有默认转换，只要是这种格式
                        //创建表
                        create table t_student1(
                            id int(11),
                            name carchar(32),
                            birth:date,
                            create_time:datetime
                        )
                        //插入数据
                        insert into t_student(id,name,birth,create_time) values(11,'zhagnsan','1990-10-01','1990-10-01 12:02:30')
                    5.插入带有系统时间的数据
                        --获取系统时间
                            now() 函数，获取系统当前时间，且带有时分秒信息
                            insert into t_student(id,name,birth,create_time) values(11,'zhagnsan','1990-10-01',now())

            4.DML语句———修改表中的数据update
                --update 表名 set 字段名=值1,字段名=值2,,字段名=值3... where 条件
                    --注意：没有条件限制，会导致所有的数据全部更新,即所有的数据都会被修改
                --案例：
                    update t_study1 set name='lisi1',birth='2000-10-05' where id=2; //修改id=2的数据，修改其name,birth
                
            5.DML语句———删除表中的数据delete
                --delete from 表名 where 条件;
                    --注意：没有条件的限制，整张表的数据都会被删除
                    --原理：一个一个数据删除，但删除完成后其中的空间还在，
                    --优点：是之后还可以进行恢复  
                            前提：已经执行事务  start transaction
                            使用rollback回滚，恢复数据
                                --$rollback
                            --执行事务和rollback;是配套的，只有执行了事务，才能回滚
                    --缺点：删除的效率比较低
                --案例：
                    delete from t_study1 where id=2;  //删除表中id=2的数据
                    delete from t_study1; //删除整张表的所有数据

            6.insert插入多条数据
                --insert into 表名(z字段名1，字段名2) values(),(),()...;
                    insert into t_study1(id,name,birth) values
                    (3,'zhangsan','1999-10-12'),
                    (4,'lisu','2000-04-01')

            7.表的复制
                --create table 创建的表名 as 查询语句
                    create table t_study2 as select * from t_study1  //创建表t_study2,并将表t_study1的内容写入创建的表t_study2中
                --create table test1 as select name,job from test where name='testData'  //将表test中name=testData的数据复制到新建的表test1中
                --原理：将一个查询结果当成一张表新建，这样可完成表的快速复制
            
            8.将查询结果插入到表中
                --前提：查询结果符合插入表的数据结构，即查询结果和插入的表的数据结构一一对应
                insert into 表名 查询语句
                    --insert into test1 select * from test   //将t从test中查到的数据插入到test1表中

            9. DDL---删除大表
                --$truncate table user_table
                --注意：删除后不可恢复
                        删除的是表中的数据，表还在
                --优点：删除效率比较高，表被一次截断，物理删除
                --缺点：删除后数据不可恢复，不支持回滚

            
            1.表的约束
                --英文：constraint
                --在创建表的时候，我们可以给表总的字段数据加上一些约束，来保证这个表中的数据的完整性，有效性
                --作用：
                    为了保证表中数据的有效性，完整性，
                --常见的约束：
                    --非空约束 not null  只有列级约束，没有表级约束
                    --唯一性约束 unique  列级约束  表级约束
                    --主键约束：primary key (简称 PK)  列级约束 表级约束
                    --外键约束： foreign key (简称 FK)
                    --检查约束： check (mysql不支持，oracle支持)
                --注意：
                    --约束添加在列字段的后面，被称为列级约束 
                        create table test(
                            id not null,  //列级约束
                            name
                        )
                    --约束没有添加到列的后面，被称为表级约束
                        create table test(
                            id,
                            name,
                            unique(id,name)  //表级约束，id和name字段联合起来具有唯一性
                        )
            2.非空约束
                --非空约束not null的字段不能为null
                --案例：
                    create table user1(
                        id int(32) not null,  //表示id字段不能为空
                        name varchar(32) not null, //表示name字段不能为空
                        password varchar(255)  not null //表示password字段不能为空
                    )

            3.唯一性约束
                --唯一性约束unique的字段不能重复，但是可以为null（即在表中该字段的数据不能重复）
                --案例：
                    create table user1(
                        id int(32) unique  //表示id字段不能重复，不能有两个相同的id
                        name varchar(32) , 
                        password varchar(255) 
                    )

            4.多个字段联合约束
                --多个字段联合起来约束
                案例：
                    --name和email字段联合起来具有唯一性
                        --符合的数据
                            --name:'zhangsan',email:'zhangsan@123.com'
                            --name:'zhangsan',email:'zhansan@qq.com'
                    create table user1(
                        id int(32) ,
                        name varchar(32) , 
                        password varchar(255) ,
                        email varchar(32),
                        unique(name,email)
                    )  
            
            5.多个约束使用在同一字段
                --多个约束联合设置字段，例如 name同时具有非空性，唯一性
                create table user1(
                    id int(32) not null unique,
                    name varchar(32) , 
                    password varchar(255) ,
                    email varchar(32),
                )  
                注意：在mysql中，一个字段同时被not null,unique约束，则该字段自动变成主键字段（Oracle中不一样）
            
            6.主键约束
                --一张表中主键一般只有一个，且主键值一般都是数字，int/bigint/char等类型
                --主键是唯一的，且不能重复
                --相关术语
                    主键约束 ：就时一种约束
                    主键字段：该字段上添加了主键约束，这样的字段叫做 主键字段
                    主键值：主键字段上的每一个值都叫做主键值
                --作用和定义
                    主键值是每一行记录的唯一标识，类似于是每一行记录的身份证号
                --注意：
                    任何一张表都应该要有主键，没有的主键的表是无效的
                    实际开发中不建议使用复合主键，一般使用单一主键
                --特征：
                    not null  unique （主键值不能为null，同时也不能重复）
                --案例：
                    //单一主键
                    create table user1(
                        id int primary key,   //设置id为主键字段
                        name varchar(32) , 
                        password varchar(255) ,
                        email varchar(32),
                    )  
                    //单一主键
                    create table user1(
                        id int,   
                        name varchar(32) , 
                        password varchar(255) ,
                        email varchar(32),
                        primary key(id)  //id做主键
                    )  
                    //复合主键
                    create table user1(
                        id int,   
                        name varchar(32) , 
                        password varchar(255) ,是
                        email varchar(32),
                        primary key(id,name)  //id和name联合起来做主键
                    )  
                --主键也可分为自然主键和业务主键
                    --自然主键：主键值是一个自然数，和业务没关系
                    --业务主键：主键值和业务紧密联系，例如拿银行卡账号做主键值
                    实际开发中，自然主键使用的比较多，因为主键只要做到不重复就好，不需要有意义。
                    使用业务主键，一旦业务发生改变，可能会影响到主键值

            7.mysql中的自动维护主键
                --案例：主键自增
                create table user1(
                    id int primary key auto_increment,  //id做主键 且主键自增 
                    name varchar(32) , 
                    password varchar(255) ,
                    email varchar(32),
                )  
            
            8.外键约束
                --相关术语：
                    外键约束：外键约束
                    外键字段：添加外键约束的字段
                    外键值：外键字段的每一个值
                --作用：约束某字段只能取固定的一些值 类似性别只有男/女，不能写其他值
                --案例：
                    设置班级和学生信息
                        班级表中存在cno班级编号，班级名称classname
                        学生表中存在no编号，name,cno班级编号（100，101）
                            --通过cno字段连接两表的关系
                        --当cno字段没有任何约束的时候，可能会导致出现无效的字段，可能会出现102，103等，但cno字段中不存在102，103
                            为了保证cno字段中的值是100，101，而不是其他的值，需要给cno字段添加外键约束
                            此时cno字段就是外键字段，cno字段中的值就时外键值
                        --给学生表的cno添加外键约束
                        --学生表是子表，班级信息表是父表
                --添加外键约束后，存在父子关系
                    --添加外键约束的字段所存在的表是子表，外键约束内容的表是父表
                --注意：
                    删除表的顺序：先删除子表，再删除父表（因为子表中使用外键约束的字段，先删除才不出错）
                    创建表的顺序：先创建父表，再创建子表
                    插入数据：先插入父表，再插入子表
                    子表引用父表的某个字段，该字段不一定是主键，但是该字段的值必须具有unique唯一性，不能重复
                --使用：
                    先创建父表
                    create table t_class(
                        classno int primary key,
                        classname varchar(255)
                    )
                    再创建子表,添加外键约束
                    create table t_student(
                        no int  primary key auto_increment,  //主键自增
                        name varchar(255),
                        cno int,
                        foreign key(cno) references t_class(classno)  //外键是cno，引用的是t_class表中的calssno
                    )
            
            9.存储引擎
                --定义：MySQL中的特有的一种术语，其他的数据库中没有，Oracle中也存在，不过并不是叫这个名字
                        存储引擎是一个表存储/组织数据的方式
                        不同的存储引擎，表存储的数据的方式不同
                --添加/指定存储引擎：
                    --展示该表的存储引擎（ENGINE=... DEFAULT CHARSET=utf8）
                        $show create table 表名   （展示建表时的sql语句，其中存在存储引擎）
                            --+-------+--------------------------------------------------------------------------------------------------------------------+
                            | Table | Create Table                                                                                                       |
                            +-------+--------------------------------------------------------------------------------------------------------------------+
                            | user1 | CREATE TABLE `user1` (
                            `id` int NOT NULL,
                            `name` varchar(32) DEFAULT NULL
                            ) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
                    
                    --指定存储引擎
                        --建表的时候可以在最后小括号‘)’的右边使用,指定存储引擎以及编码方式
                            ENGINE来指定存储引擎
                            CHARSET来指定这张表的字符编码方式
                            --create table userTest(
                                ...
                            ) ENGINE=InnoDB DEFAULT CHARSET=utf8
                    --注意：
                        mysql的默认的存储引擎是InnoDB
                        mysql的默认的字符集编码方式是utf8

            10.mysql支持的存储引擎
                --使用命令
                    $show engines \G  (展示当前数据库mysql的版本所支持的存储引擎)
                --注意：
                    mysql支持九大存储引擎，当前版本不同，支持的情况不同
                --常用的存储引擎：
                    InnoDB 
                        这是mysql默认的存储引擎，同时也是一个重量级的存储引擎
                        每个表都以.frm格式的文件表示
                        InnoDB支持事务（事务就是解决安全性问题），安全性高，支持数据库奔溃后自动恢复机制
                        InnoDB表空间tablespace被用于存储表的内容（表空间是一个逻辑名称，表空间存储数据+索引）
                        特点：
                            安全性高
                            为了保证数据的安全性，效率不是很高，并且也不能压缩，不能转换为只读
                    MyISAM存储引擎:
                        它管理的表具有的特点：
                            使用三个文件表示每个表：
                                格式文件——存储表结构的定义（一般是存储在frm文件中，例如 mytable.frm）
                                数据文件——存储表行的内容（一般存储在MYD文件中，例如 mytable.MYD）
                                索引文件——存储表上索引（一般存储在MYI文件中，例如 mytable.MYI）  索引相当于一本书的目录，缩小扫描的范围 
                        具备的特点：
                            --可被转化为压缩，只读表来节省空间，同时也是优势
                            --安全性低，不支持事务
                    MEMORY存储引擎：
                        使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定
                        这两个特点使得MEMORY存储引擎非常快
                        特点：
                            --每个表都是以.frm格式的文件表示
                            --表的索引及数据都存储在内存中
                            --表级锁机制
                            --不能包含TEXT或BLOB字段
                        优点：
                            查询效率高，
                            不安全，关机后数据立即消失。因为数据和索引是保存在内存中

            11.事务
                --一个事务其实就是一个完整的业务逻辑，是一个最小的工作单元，不可再分
                --一个事务说到本质，其实就是多条DML语句同时成功，或者同时失败 
                完整的业务逻辑：
                    类似于转账，A转账B，A和B的账户的钱同时发生变化，这就是一个完整的业务逻辑
                    就是两个update语句必须同时成功或者同时失败，这样才才能保证钱是正确的，业务逻辑正确的 
                --只有DML语句才有事务，即是，增，删，改，语句才会有事务，其他语句和事务无关
                --涉及到数据的增删改（需要多个DML语句共同联合起来才能完成），就一定要考虑到安全性问题，即需要考虑到事务
                --注意：
                    如果只有一条DML语句就完成的业务逻辑，那么就不考虑事务，因为没有意义
                    mysql默认的情况下，支持自动提交事务的(默认自动提交事务，每执行一条DML语句，就提交一次)
            
            12.事务的使用（transaction）
                --事务怎样做到多条DML语句同时成功或者同时失败的
                    InnoDB存储引擎，提供了一组用来记录事务性活动的日志文件
                --过程：
                    在事务的执行过程中，每一条的DML的操作都会被记录到‘事务性活动的日志文件’中
                    在执行过程中，我们可以提交事务，也可以回滚事务
                --提交事务：
                    清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中，即完全改变数据库
                    提交事务标志着事务的结束，并且是一种全部成功的结束
                --回滚事务：
                    将之前的所有的DML操作全部撤销，并且清空事务性活动的日志文件
                    回滚事务标志着事务的结束，并且是一种全部失败的结束
                --使用：
                    提交事务：  commit;语句
                    回滚事务：  rollback;语句（永远只能回滚到上一次的提交点）
                    关闭mysql的默认自动提交机制：
                        $start transaction (开启事务，同时关闭自动提交机制，此时才可以使用commit和rollback)
                        --因为这种自动提交实际上是不符合开发习惯的，因为一个业务通常是需要多条DML语句共同执行才能完成，
                            为了保证数据的安全，必须要求同时成功之后再提交，所以不能执行一条就提交一条
                --案例：   
                    $start transaction;  //开启事务
                    $insert into user(id,name) values(1,'zhansan'),(2,'lisi'); //插入数据
                    $commit; //进行事务提交
                    $rollback;  //有commit操作，则回滚到上次提交commit的点，即执行commit完成之后的表
                                //没有执行commit操作，则回滚到开启事务的时候，即是将之前的所有DML操作全部撤销

            13.事务的特性
                四大特性：
                    原子性（A）：说明事务是最小的工作单元，不可再分
                    一致性（C）：所有事务要求，在同一事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性
                    隔离性（I）：A事务和B事务之间具有一定的隔离
                                相当于多线程并发访问同一张表一样
                    持久性（D）：事务最终结束的一个保障，事务提交，就相当于将没有保存到硬盘上的数据保存到硬盘上
            
            14.事务的隔离级别
                --事务和事务之间的隔离级别（4个）：
                    读未提交：read uncommitted （最低的隔离级别）
                            --定义：
                                事务A可以读取到事务B未提交的数据
                            --存在问题：
                                会导致脏读现象(Dirty Read)
                                称之为，读取到了脏数据
                                不过这种隔离级别是理论上的，大多数都是数据库隔离级别都是从‘读已提交’开始
                    读已提交：read committed
                            --定义
                                事务A只能读取到事务B提交后的数据
                            --优点：
                                解决了脏读现象
                                这种隔离级别比较真实，每一次读取的数据都是绝对真实的
                            --存在问题：
                                不可重复读取数据
                                    --即事务开启之后，第一次读取的数据和第二次读取的数据并不相等，例如第一次读取的数据是3条，
                                        可能第二次读取的数据是4条，3不等于4，称之为不可重复读取（因为事务没结束之前，都会存在DML语句执行，每次的数据当然不一样）
                            
                    可重复读：repeatable read
                            --mysql中默认的事务隔离级别
                            --永远读取的都是刚开启事务时的数据
                            --定义：
                                事务A开启之后，不管多久，每一次在事务A中读取的数据都是一致的，即便事务B将数据已经修改，
                                并且提交了，事务A读取的数据还是没有发生改变，这就是可重复读
                            --优点：
                                解决了不可重复读的问题
                            --存在的问题：
                                可能出现幻影
                                每一次读取的数据都是幻想，不够真实

                    序列化/串行化：serializable (最高的隔离级别)
                                --定义：
                                    --这种隔离级别最高，但效率最低
                                    --每一次读取的数据都是最真实的，但效率最低
                                    --事务可以是排队的，同时对一张表进行事务执行，没commit之前，
                                      第一个事务执行了操作，第二个事务会进行等待，等待第一个事务进行commit,第一个事务commit完成后，
                                      第二个事务才会开始执行，并出现本身执行的结果
                                存在的问题：
                                    效率低
                                    这种隔离级别表示事务排队，不能并发
                                --解决了其他隔离级别出现的问题
                --设置（查看）事务隔离级别：
                    设置全局隔离级别(在刚登录mysql的时候，可设置)
                        --$set global transaction isolation level read uncommitted;  //设置全局的隔离级别为read uncommitted
                    查看当前会话隔离级别
                        --$select @@tx_isolation

            15.索引
                --索引是数据库表的字段行添加的，是为了提高查询效率存在的一种机制，一张表的一个字段可以添加一个索引，
                    当然，多个字段联合起来也可以添加索引，索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制
                --添加索引：先通过索引直接定位到一个大概的位置，做局域性扫描，缩小扫描的范围，拿到硬盘中的此地的物理存储编号，
                            快速的查找————通过索引检索
                --未添加索引：一张表一张表的查找，直到查找到相关的符合条件的数据，效率过低————全表检索
                --案例：
                    select * from user_login where name='jack'
                    //在name字段上添加索引，其会直接在name字段上扫描，相当于直接找出，不用进行一个一个的对比查找
                    //name上不存在索引，其会将name字段上的每一个值都对比一次，效率过低
                --注意：
                    --在mysql中索引也是需要进行排序的，其数据结构和TreeSet数据结构相同（自平衡的二叉树），
                        在mysql中索引是一个B-Tree的数据结构，遵循左小右大的原则，采用中序遍历方式遍历数据
                    --在任何数据库中，主键上都会自动添加索引对象，id字段上自动有索引，id是主键。另外在mysql中
                        一个字段存在unique的约束，也会自动创建索引对象
                    --在任何数据库中，任何一张表的任何一条记录在硬盘行存储都会有一个硬盘的物理存储编号

            16.需要添加索引的情况
                --情况1：数据量庞大
                --情况2：该字段经常出现在where的后面，以条件的形式存在，也就是说该字段经常被扫描查询的时候
                --情况3：该字段很少的DML操作（因为DML之后，索引需要进行重新排序）
                --创建索引：
                    $create index 索引名 on 表名(字段名)
                    $create index emp_ename_index on emp(ename)   //给emp中的ename字段添加索引emp_ename_index
                --删除索引：
                    $drop index emp_ename_index on emp;   //在emp表中删除索引对象emp_ename_index
                --在mysql中，查看一个sql语句是否使用了索引进行检索：
                    $explain select * from emp where name='jack'
                    //通过查看输出结果中的rows，查看扫描的rows，判断是全表数据条数还是一条数据，
                        一条数据就是添加了索引进行检索，否则就是没有，是全表查询

            17.索引失效的情况
                --1.使用了模糊查询'%'
                    $select * from user_table where name='%T' //查找表中以T结尾的数据(模糊查询)
                    此时即使是设置添加了索引，其查询也不会通过索引进行查询，因为查找必须第一个匹配的字符，就需要进行一个一个查询
                    --注意：
                        尽量避免模糊查询的时候使用'%'开头
                --2.使用了or的时候失效，如果使用了or，那么就需要要求两边的条件都要有索引，这样才会走索引。
                    --如果一个存在索引，一个不存在索引，那么存在索引的一方的索引也会失效
                    --注意：
                        不建议过多使用or
                    --解决方法：
                        --可以使用union，实现or的功能。union并不会使索引失效
                --3.使用复合索引的时候，没有使用左侧的列查找，索引失效
                    --复合索引：
                        两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引
                        $create index emp_name_index on emp(name,job)  //job和name联合起来添加索引
                    --添加复合索引的时候emp(name,job),使用name进行查询，可通过索引检索。但使用job进行查询，索引检索将会失效
                --4.在where中，索引列(字段的值)参加了数学运算，索引失效
                    $create index sal_index on user_table(sal);
                    $select * from user_table where sal+1=800;
                --5.在where当中，索引列使用了函数
                    $ select * from user_table where lower(name)='smith'

            18.索引的分类
                --索引是数据库优化的重要手段，优化的时候优先考虑的因素就是索引
                --索引的分类：
                    单一索引：一个字段上添加索引
                    复合索引：多个字段上添加索引
                    主键索引：主键上添加索引
                    唯一性索引：具有union约束的字段上添加索引
                    --注意：
                        唯一性比较弱的字段上(该字段可能存在大量重复的数据)添加索引的用处不大
                        唯一性越高，该索引检索的效率越高

            19.视图（view）
                --定义：
                    站在不同的角度看待同一份数据
                --创建视图对象
                    create view 视图名 as 当成视图的查询结果（只能是DQL语句，即查询语句）
                    create view emp_view as select * from emp;  //将select * from emp的查询结果当成视图创建出来
                --删除视图：
                    drop view 视图名
                    drop view emp_view
                --视图的增删改查：
                    我们可以面向视图进行增删改查（c,r,u,d），对视图对象的增删改查，会导致原表被操作（视图特点：会影响到原表的数据）
                    //查询
                    select * from emp_view;   //面向emp_view视图的查询
                    //增
                    insert into emp_view(id,name) values(1,'lisi')  //面向emp_view视图的增数据
                --作用：
                    --简化sql语句，将查询结果简化，简化开发
                     （可能有一条sql语句需要多次使用，且其语句很长，此时就可以使用视图将该sql语句简化成一个视图对象进行使用）

            20.DBA命令
                重点：
                    --导入
                        --$source D:\empnode.sql -uroot -proot
                    --导出
                        window的dos命令窗口：
                        导出数据库：
                            --$mysqldump empnode>D:\empnode.sql -uroot -proot
                            --$mysqldump 数据库名>本地路径(需要导入的路径) -u用户名 -p密码
                        导出数据库中的表：
                            --$mysqldump empnode emp>D:\empnode.sql -uroot -proot   //淡出empnode数据库中的emp表
                            --$mysqldump 数据库名 表名>本地路径(需要导入的路径) -u用户名 -p密码

            21.数据库设计范式
                --数据库表的设计依据
                --设计范式：
                    第一范式：要求任何一站表必须有主键，每一个字段原子性不可再分
                    第二范式：建立在第一范式的基础上，要求所有非主键字段完全依赖主键，不要产生部分依赖
                                --产生部分依赖大部分原因：  使用了复合主键的缘故
                                --案例： 表中存在  学生编号+教师编号（pk） 学生姓名 教师姓名
                                            ---不满足第二范式，非主键字段和主键字段之间产生了部分依赖（教师姓名依赖教师编号，学生姓名依赖学生编号）
                                --改进： 使用三张表来表示多对多的关系
                                         学生表（学生姓名，学生编号）  教师表（教师姓名，教师编号）   学生教师关系表（id,学生编号(fk)，教师编号(fk)）
                    第三范式：建立在第二范式的基础上，要求所有非主键字段直接依赖主键，不要产生传递依赖
                                --案例：（描述一个教室有多个学生）表中存在  学生编号（pk） 学生姓名 班级编号 班级名称
                                        ---满足第一范式，满足第二范式（因为不是复合主键），但不满足第三范式（因为班级名称依赖班级编号，班级编号又依赖主键学生编号，产生传递依赖）
                                --改进： 使用两张表表示 
                                        --学生表（学生姓名，学生编号(pk)，班级编号(fk)） 
                                        --班级表（班级名称，班级编号(pk)）
                --作用：可以避免表的数据的亢余和空间的浪费
                --使用场景：
                    一对多关系：  一对多，两张表，多的表添加外键
                    多对多关系：  多对多，三张表，关系表两个外键
                    一对一关系：  一对一，外键唯一
                                --实际开发中，可能存在一张表的字段太多，数据过于庞大，此时就需要进行拆分表
                                --两张表通过使用一个外键进行连接，外键字段选取唯一性较高的字段
                                    案例：用户表拆分成两张表
                                        用户登录表： id(pk) name password
                                        用户信息表： id(pk) real_name email  address  login_id(fk)
                                        --通过创建一个外键字段login_id来表示该用户是哪个登录用户，同时连接两张表
                --注意： 实际开发中，有时需要将亢余换成执行速度！！！！！
                        有时表的设计可能存在亢余，但为了减少表的连接，尽量避免笛卡尔积，使sql语句的执行速度变快
                        可不遵守数据库设计范式！！！！！


        */
    </script>
</body>
</html>